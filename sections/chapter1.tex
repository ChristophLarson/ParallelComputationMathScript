%\chapterimage{chapter_head_2.pdf} % Chapter heading image

%----------------------------------------------------------------------------------------
\chapter{Introduction C++}
%----------------------------------------------------------------------------------------
This chapter gives a brief introduction to the core features of the C++ language. However, the focus on this chapter is to introduce the C++ standard template library, see Section~\ref{chapter:stl}, which is essential to implement mathematical equations and algorithms. Therefore, we quickly look into these features as we need them to implement the numerical examples in Part~\ref{part:numerical:examples}. For more details we refer to
\begin{itemize}
\item \fullcite{andrew2000accelerated}
\end{itemize}
since this book gives an excellent pragmatic overview with a lot of examples. For even more C++ basics, we refer to
\begin{itemize}
\item \fullcite{stroustrup2014programming}.
\end{itemize}
%----------------------------------------------------------------------------------------
\section{History of C and C++}
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
\section{Getting started with C++}
%----------------------------------------------------------------------------------------
To begin with C++ programming, we look at a simple C++ program, the so-called ``Hello World'' example which most programming language start with. Listing~\ref{code:hello:world} shows this program and the first line in green a comment is shown. A  single-line comments always starts with \lstinline[language=C++]|//| and is used to explain the functionality of the program or the next lines of codes. It is also possible to use multi-line comments\endnote{\url{https://en.cppreference.com/w/cpp/comment}} by using \lstinline[language=C++]{/* */}. Comments are important to understand the program, especially if the code is shared with other collaborators. Fore more details we refer to~\cite{kernighan1974elements}.

The second line starts with a so-called include directive\endnote{\url{https://en.cppreference.com/w/cpp/preprocessor/include}} \lstinline[language=C++]{#include <iostream>}. This include directive is needed to include functionality of the C++ standard library, see Chpater~\ref{chapter:stl}, in our case we include the \lstinline|iostream| header to print the Hello World to the terminal, see Line 6.

The fourth line \lstinline[language=C++]{int main()} starts with the so-called Main function\endnote{\url{https://en.cppreference.com/w/cpp/language/main_function}} which is the entry point of the program and all code lines within are executed sequentially one by one. Every C++ which will be compiled to an executable needs exact one function called \lstinline[language=C++]|main| which have a integer \lstinline[language=C++]{int} as its return type. On most operation systems a return value of zero means that the program executed successfully and any other value indicates an failure. The second last line \lstinline[]|return| is the so--called return statement\endnote{\url{https://en.cppreference.com/w/cpp/language/return}} which has to match the return type in front of the \lstinline[language=C++]{int main()}.


\lstinputlisting[language=C++,caption={A simple C++ program, the so-called ``Hello World'' example, which most languages start with.\label{code:hello:world}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture1-main.cpp}

Once we have written the program, we have to compile the C++ code into an executable to run the code and print ``Hello world'' to the terminal. Note that there are plenty of C++ compilers\endnote{\url{https://en.wikipedia.org/wiki/List_of_compilers\#C++_compilers}} available, however this book will use the GNU Compiler Collection (GCC) for all examples. Line 1 in Listing~\ref{code:hello:world:compile} shows how to compile the file \lstinline[language=bash]|lecture1-1.cpp|, which contains the C++ code in Listing~\ref{code:hello:world}, to an executable. The GCC provides the \lstinline[language=bash]{g++} compiler to compile C++ code and the \lstinline[language=bash]{gcc} compiler to compile C code. As the first argument to the \lstinline[language=bash]{g++} compiler the file name of the C++ is provided and with the \lstinline[language=bash]|-o| option the name of the executable is specified. To run the generated executable, we type \lstinline[language=bash]|./lecture-1-1| in the terminal. Note for the basic usage of the Linux terminal we refer to~\cite{newham2005learning,robbins2016bash}.

\lstinputlisting[language=bash,caption={Compilation and execution of the C++ program.\label{code:hello:world:compile}},float,floatplacement=tb,firstline=2, lastline=3]{ParallelComputationMathExamples/chapter2/lecture1-main.sh}

\begin{exercise}
Download the example program\endnote{\url{https://github.com/diehlpkteaching/ParallelComputationMathExamples}} from GitHub and compile it with your favorite C++ compiler. After you ran the example you could try to modify it, for example you could print a different text or add a second line to the output.
\end{exercise}


%----------------------------------------------------------------------------------------
\section{Fundamental data types}
%----------------------------------------------------------------------------------------
\index{data types!fundamental}
In this section the fundamental data types\endnote{\url{https://en.cppreference.com/w/cpp/language/types}} provided by the C++ language are introduced. First, the numeric data types are introduced. To represent natural numbers $\mathbb{N}=\{0,1,2,\ldots \}$ the \lstinline[language=C++]|unsigned int| data type is available. To represent integer numbers $\mathbb{Z}=\{\ldots,-2,-1,0,1,2,\ldots \}$ the \lstinline[language=C++]|int| data type is available. For all these data types following options: \lstinline[language=C++]|short|, \lstinline[language=C++]|long|, and \lstinline[language=C++]|long long| are available. In the \cpp{#include <climits>}\link{https://en.cppreference.com/w/cpp/header/climits} header the minimal and maximal value of all integer data types are defined. For example the minimal value of \cpp{int} data type is given by \cpp{INT_MIN} and the maximal value by \cpp{INT_MAX}, respectively. For more details about the binary numeral system we refer to~\cite{gilli1965binary}. 

To represent real numbers $\mathbb{R}$ the \lstinline[language=C++]|float| data type and \lstinline[language=C++]|double| data type are available. In the \cpp{#include <cfloat>}\link{https://en.cppreference.com/w/cpp/header/cfloat} header the minimal and maximal value of all floating point data types are defined. For example the minimal value of \cpp{double} data type is given by \cpp{DBL_MIN} and the maximal value by \cpp{DBL_MAX}, respectively. 

Fore more details about the IEEE 474 standard how floating point numbers are represented in the computer we refer to~\cite{4610935,goldberg1991every}. Table~\ref{chapter2:table:datatypes} summarizes all the available numeric data types and there ranges. The next section shows how to get the range of the IEEE 474 standard how floating point numbers.

\begin{table}[h]
\centering
\begin{tabular}{lccc}
\toprule
Data type & Size (Bytes) & Min & Max \\\midrule
\multicolumn{4}{c}{Natural numbers $\mathbb{N}$ }\\\midrule
\lstinline[language=C++]|unsigned short int| & 2 & 0 & 65,535  \\ 
\lstinline[language=C++]|unsigned int| & 4 & 0 & 4,294,967,295 \\ 
\lstinline[language=C++]|unsigned long int| & 4 & 0 & 4,294,967,295 \\ 
\lstinline[language=C++]|unsigned long long int| & 8 & 0 & 8,446,744,073,709,551,615 \\ \midrule
\multicolumn{4}{c}{Integer numbers $\mathbb{Z}$ }\\\midrule
\lstinline[language=C++]|short int| & 2 & -32,768 & 32,768 \\
\lstinline[language=C++]|int| & 4 & -2,147,483,648 & 2,147,483,648 \\
\lstinline[language=C++]|long long int| & 8 & $-2^{63}$ & $2^{63}-1$ \\\midrule
\multicolumn{4}{c}{Real numbers $\mathbb{R}$ }\\\midrule
\lstinline[language=C++]|float| & 4 &  &  \\
\lstinline[language=C++]|double| & 8 &  &  \\
\bottomrule
\end{tabular} 
\caption{Overview of the fundamental numeric data types.}
\label{chapter2:table:datatypes}
\end{table}

To represent a boolean value $\mathbf{B}=\{0,1\}$ the \lstinline[language=C++]|bool| data type which has either one of the two values \lstinline[language=C++]|true| or \lstinline[language=C++]|false|. Note that the C++ STL offers \lstinline|std::complex|\endnote{\url{https://en.cppreference.com/w/cpp/numeric/complex}} for complex number $\mathbb{C}$, however, this one is not within the fundamental data types.

%----------------------------------------------------------------------------------------
\section{Statements and flow control}
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
\subsection{Iteration statements}
\label{sec:iteration:statements}
%----------------------------------------------------------------------------------------
\index{statements!iteration} For some applications, we have to repeat some operations multiple times. The C++ language provides the so-called iteration statements. There are two iteration statements, the \lstinline[language=C++]|for| loop and the \lstinline[language=C++]|while| loop, respectively. Let us look how to compute the sum of the numbers from one up ton $n$
\begin{align}
r = \sum\limits_{i=1}^n i\text{.}
\end{align}
The first option is using a \lstinline[language=C++]|for| loop statement\endnote{\url{https://en.cppreference.com/w/cpp/language/for}}\index{loop!for statement} which shown in Listing~\ref{code:for:loop}. Line 9 shows the \lstinline[language=C++]|for| loop statement with its three arguments. First, the so--called loop variable \lstinline[language=C++]{size_t i = 0} which is initialized to zero. Note that the loop variable is only defined within the loop's body (The part between the curly braces). Second, the so--called condition statement \lstinline[language=C++]{i < n} which means that the loop body is repeated until the variable $i$ is larger than $n$. The third statement manipulates the loop variable, in our case the loop variable is incremented by one after the loop body was executed once. Note that we use the \lstinline[language=C++]|for| loop statement, if we know how often we have to loop through the loop body in advance.


\lstinputlisting[language=C++,caption={Computation of the sum from one up to $n$ using the for loop statement. \label{code:for:loop}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture1-for.cpp}

The second option is using a \lstinline[language=C++]|while| loop statement\endnote{\url{https://en.cppreference.com/w/cpp/language/while}}\index{loop!while statement} which shown in Listing~\ref{code:while:loop}. Line 10 shows the \lstinline[language=C++]|while| loop statement with its one argument. This is the so-called condition statement  \lstinline[language=C++]{i < n} which means that the loop body is repeated until the variable $i$ is larger than $n$. Note in the previous example we had three arguments. Here, the loop variable is declared before the loop in Line 9 and the third statement is  in Line 13 where the loop variable is incremented by one in each iteration. Note that we use the \lstinline[language=C++]|while| loop statement, if we do not know the amount of iterations in advance. This example has shown that we can write every \lstinline[language=C++]|for| loop statement as a \lstinline[language=C++]|while| loop statement. For more details we refer to~\cite[Chapter~2]{andrew2000accelerated}.   


\lstinputlisting[language=C++,caption={Computation of the sum from one up to $n$ using the while loop statement..\label{code:while:loop}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture1-while.cpp}

\begin{exercise}
Define in your own words in which case you should use a \lstinline[language=C++]|for| loop statement and a \lstinline[language=C++]|while| loop statement. 
\end{exercise}

%----------------------------------------------------------------------------------------
\subsection{Selection statements}
%----------------------------------------------------------------------------------------
\index{statements!selection}
For some applications, we have to select different behavior of the code depending on conditions. Equation~\ref{eq:chapter2:if} shows how to compute the sum from one to $n$ with different cases for even and odd numbers, If the number is even the number keeps the same and for odd numbers the number is squared.
\begin{align}
r = \sum\limits_{i=1}^n f(i) \text{  with  } f(i) = 
\begin{cases}
i, \text{ if } i \text{ is even} \\
i^2, \text{ else}
\end{cases}
\label{eq:chapter2:if}
\end{align}
Listing~\ref{code:example-if} shows the implementation of Equation~\ref{eq:chapter2:if} using a \lstinline[language=c++]{for} loop. The skeleton of the \lstinline[language=c++]{for} loop is identical to the one in Listing~\ref{code:for:loop}, but the \lstinline[language=c++]{if} statement\endnote{\url{https://en.cppreference.com/w/cpp/language/if}} in Line 8 is added to switch between even and odd numbers. The \lstinline[language=c++]{if} statement takes exactly one argument, the so--called condition statement. If the statement is evaluated as \lstinline[language=c++]{true} the code line between \lstinline[language=c++]{if} and \lstinline[language=c++]{else} is selected.  If the statement is evaluated as \lstinline[language=c++]{false} the code line after \lstinline[language=c++]{else} is selected. Multiple lines of codes have to be between curly braces. It is also possible to use \lstinline[language=c++]{else if} after the first \lstinline[language=c++]{if}. \\

\lstinputlisting[language=C++,caption={Computation of the sum from one up to $n$ using the selection statement.\label{code:example-if}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture1-if.cpp}


The second selection statement is the \lstinline[language=c++]{switch} statement\endnote{\url{https://en.cppreference.com/w/cpp/language/switch}}. For example this statement can be used to execute different code branches depending on a single variable. Listing~\ref{code:example-switch} shows one example to write the name of the color to the standard output. In this case we use a enumeration \lstinline[language=c++]{enum}\endnote{\url{https://en.cppreference.com/w/cpp/language/enum}} to store the colors. The \lstinline[language=c++]{switch} takes one argument and execute the code between the matching \lstinline[language=c++]{case} and the following \lstinline[language=c++]{break}. For more details we refer to~\cite[Chapter~2]{andrew2000accelerated}.  


\lstinputlisting[language=C++,caption={Computation of the sum from one up to $n$ using the selection statement.\label{code:example-switch}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture1-switch.cpp}


%----------------------------------------------------------------------------------------
\subsection{Operators}
%----------------------------------------------------------------------------------------
\index{Operators}
For the example in Listing~\ref{code:for:loop} we have seen the operator \lstinline[language=C++]|i<n| which is a so--called comparison operator. Next to the comparison operators, C++ language has following operators\endnote{\url{https://en.cppreference.com/w/cpp/language/operator_precedence}}:
\begin{itemize}
\item Comparison operators, see Table~\ref{sec:1:tab:operator:comp},
\item Arithmetic operators, see Table~\ref{sec:1:tab:operator:arithmetic},
\item Logical operators, see Table~\ref{sec:1:tab:operator:logical}, and
\item Assignment operators, see Table~\ref{sec:1:tab:operator:assign},
\end{itemize}
 logical operators, arithmetic, and assignment.

\begin{table}[p]
\centering
\begin{tabular}{clll}
\toprule
Operator & Name  & Example \\ 
\midrule
\lstinline|==| & Equal to & \lstinline|x==y|\\ 
\lstinline|!=| & Not equal & \lstinline|x!=y|\\ 
\lstinline|>| & Greater than & \lstinline|x > y|\\ 
\lstinline|<| & Less than & \lstinline|x < y|\\ 
\lstinline|>=| & Greater than or equal & \lstinline|x >= y|\\ 
\lstinline|<=| & Less than or equal & \lstinline|x <= y|\\ 
\bottomrule 
\end{tabular} 
\caption{Comparison operators}
\label{sec:1:tab:operator:comp}
\index{Operators!comparison}
\end{table}

\begin{table}[p]
\centering
\begin{tabular}{clll}
\toprule
Operator & Name & Description & Example \\ 
\midrule
\lstinline|+| & Addition & Computes the sum of two values & $2+2=4$ \\ 
\lstinline|-| & Subtraction  & Computes the difference of two values & $5-3=2$ \\ 
\lstinline|/| & Division & Divides two values & $6/2=3$ \\ 
\lstinline|*| & Multiplication & Multiplies two values & $2\times2=4$ \\ 
\lstinline|%| & Modulo &  	Returns the division remainder & \lstinline|2%1=0| \\ 
\lstinline|++| & Increments & Add plus one to the value & \lstinline|1++=2|\\ 
\lstinline|--| & Decrements & Subtract one of the value & \lstinline|1--=0|\\ 
\bottomrule 
\end{tabular} 
\caption{Arithmetic operators}
\label{sec:1:tab:operator:arithmetic}
\index{Operators!arithmetic}
\end{table}


\begin{table}[p]
\centering
\begin{tabular}{clll}
\toprule
Operator & Name & Description & Example \\ 
\midrule
\lstinline|&&| & Logical and & Returns \lstinline|true| if both statements are true  & \lstinline| x > 5 && x < 10| \\ 
\lstinline|||| & Logical or  & Returns \lstinline|true| if one statement is true & \lstinline| x > 5 || y < 10| \\ 
\lstinline|!| & Logical not &  Inverse the statement & \lstinline| !(x > 5 && x < 10)| \\ 
\bottomrule 
\end{tabular} 
\caption{Logical operators}
\label{sec:1:tab:operator:logical}
\index{Operators!logical}
\end{table}


\begin{table}[p]
\centering
\begin{tabular}{clll}
\toprule
Operator & Name & Example & Equivalent  \\ 
\midrule
\lstinline|=| & Assignment &   \lstinline| x = 5| &   \lstinline| x = 5 | \\ 
\lstinline|+=| & Plus equal  & \lstinline| x+= 5|  & \lstinline| x = x + 5 | \\ 
\lstinline|-=| & Minus equal & \lstinline| x-= 5|  & \lstinline| x = x - 5 | \\ 
\lstinline|*=| & Multiplication equal &  \lstinline| x*= 5| & \lstinline| x= x * 5| \\ 
\lstinline|/=| & Division equal &  \lstinline| x/= 5| & \lstinline| x= x / 5| \\ 
\lstinline|%=| & Modulo equal &  \lstinline| x%= 5| & \lstinline| x = x % 5| \\ 
\bottomrule 
\end{tabular} 
\caption{Assignment operators}
\label{sec:1:tab:operator:assign}
\index{Operators!assignment}
\end{table}

\begin{exercise}
Write a small C++ program using selection statements and operators to determine if a given year is a lap year. Following logical statements should be implemented: 
\begin{itemize}
	\item   If year is divided by 4 but not by 100, then it is a leap year.
    \item If year is divided by both 100 and 400, then it is a leap year.
    \item If year is divided by 400, then it is a leap year.
    \item And in all other cases, it is not a leap year.
\end{itemize}
\end{exercise}



%----------------------------------------------------------------------------------------
\section{Structuring source code}
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
\section{Functions}
\index{functions}
%----------------------------------------------------------------------------------------
To use code again and do not have to repeat code blocks multiple times, one can use function definitions\link{https://en.cppreference.com/w/c/language/function_definition}. Listings~\ref{code:functions:max} shows the definition of the function \cpp{max}. In Line~1 the return type \cpp{int} of the function is defined which means that this function will return one integer value. This is happening in Line~3 using the \cpp{return}\link{https://en.cppreference.com/w/cpp/language/return} keyword. In Line~1 the name of the function\link{https://en.cppreference.com/w/cpp/language/functions} \cpp{max} is defined and in the parentheses the function arguments are provided separated by commas. In this example two integer values with the name \cpp{a} and \cpp{b} are provided. For the return value, a short form of the \cpp{if} statement. the so--called conditional operator\link{https://en.cppreference.com/w/cpp/language/operator_other\#Conditional_operator}, is provided which means if $a>b$ return $a$ and else return $b$. The function is called as \cpp{double result = max(5,7.7)}.   \\

\begin{lstlisting}[language=c++,caption={Example for a function definition to compute the maximum of two numbers.\label{code:functions:max}},float,floatplacement=tb]
int max(int a, int b)
{
return a>b?a:b;
}
\end{lstlisting}

Function are defined between \cpp{#include} and \cpp{int main (void)} in the source code file. Listing~\ref{code:example-function} shows the usage of a function definition for the example in Equation~\ref{eq:chapter2:if}. For more details we refer to~\cite[Chapter~4]{andrew2000accelerated}.

\lstinputlisting[language=C++,caption={Example for a function definition to compute Equation~\ref{eq:chapter2:if}.\label{code:example-function}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture2-function.cpp}


%----------------------------------------------------------------------------------------
\subsection{Structs}
%----------------------------------------------------------------------------------------
For more details we refer to~\cite[Chapter~4]{andrew2000accelerated}.
%----------------------------------------------------------------------------------------
\subsection{Classes}
%----------------------------------------------------------------------------------------
For more details we refer to~\cite[Chapter~4]{andrew2000accelerated}.

\theendnotes

%----------------------------------------------------------------------------------------
\chapter{The C standard library}
\label{chapter:cpp:lib}
%----------------------------------------------------------------------------------------
The ANSI C standard\link{http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf}\index{ANSI C} is the specification for the C standard library (libc). The C standard library provides following functionality
\begin{itemize}
\item Handling set of characters in the \cpp{#include <cstring>} header,
\item handling times and dates in the \cpp{#include <ctime>} header,
\item Support of complex numbers in the \cpp{#include <ccomplex>},
\item Mathematical functions in the \cpp{#include <cmath>} header,
\item Limits of integer types in the \cpp{#include <climits>} header,
\end{itemize}
and many more features. However, these are the features we will use most in this course. 

%----------------------------------------------------------------------------------------
\section{Strings}
\index{libc!string}
\index{string}
%----------------------------------------------------------------------------------------
The STL provides the class \lstinline[language=C++]{string}\endnote{\url{http://www.cplusplus.com/reference/string/string/}} to store sequences of characters. For the usage of this class the header \lstinline[language=c++]{#include <string>} has to be added to the cpp file to make \lstinline[language=c++]{std::string} available. Listing~\ref{code:strings} shows how to use the string class to write a set of characters to standard output stream\endnote{\url{http://www.cplusplus.com/reference/iostream/cout/?kw=cout}} \lstinline[language=c++]{std::cout} and read them from standard input stream\endnote{\url{http://www.cplusplus.com/reference/iostream/cin/?kw=cin}} \lstinline[language=c++]{std::cin}. To use these functionality the \lstinline[language=c++]{#include <iostream>} header is needed. \index{iostream!cin}\index{iostream!cout} \\

In Line~7 the set of characters \lstinline[language=c++]{"Please enter your name: "} is written to the standard output stream using the operator \lstinline[language=c++]{<<}. In Line~9 a string object with the identifier \lstinline[language=c++]{name} is declared. All variables have a name \lstinline[language=c++]{name} and a type  \lstinline[language=c++]{std::string}. Since the variable is declared but not initialized yet, the variable is empty or a null string. The assignment operator \lstinline[language=c++]{=} is used to initialize the variable with a set of characters  \lstinline[language=c++]{std::string name = "Mike"}. In Line~10 the variable is initialized with the content provided by the standard input stream \lstinline[language=c++]{std::cin} and the \lstinline[language=c++]{>>} operator. In Line~12 the content of the variable is written to the standard output stream. Note that you can concatenate strings using the \lstinline[language=c++]{>>} operator multiple times. To generate a line break the statement \lstinline[language=c++]{std::endl} is used. Note that we only handled the basis features here, since these are necessary for the purpose of this course. For more details we refer to~\cite[Chapter~1]{andrew2000accelerated}.


\lstinputlisting[language=C++,caption={Example reading and writing strings.\label{code:strings}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture1-string-io.cpp}


%----------------------------------------------------------------------------------------
\section{Random number generation}
\index{libc!random number generation}
\index{random number generation}
\label{sec:random:numbers}
%----------------------------------------------------------------------------------------
For some applications, \emph{e.g.}\ Monte Carlo methods, see Chapter~\ref{sec:monte:carlo}, random numbers are essential. The trivial way to generate a integer random number in the range of zero and \cpp{RAND_MAX} is to use \cpp{std::rand}\link{http://www.cplusplus.com/reference/cstdlib/rand/} provided by the \cpp{#include <cstdlib>} header. Listing~\ref{code:srand} shows a small example to generate a random number. Note that one has to provide a seed to the random number generator to get a different random numbers each time the program is executed. One way to do so, is to use the current time \cpp{std::time(0)}\link{http://www.cplusplus.com/reference/ctime/time/?kw=time} provided by the \cpp{#include <ctime>} header. Line~10 shows how to use the current time passed as an argument \cpp{std::srand(std::time(0))} as a seed for the random number generator. Line~\mbox{12} shows how to get one random number. Note that the seed has to be set only once, but always before any random number is drawn.\\

\lstinputlisting[language=C++,caption={Example using the trivial random number generator.\label{code:srand}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture2-random.cpp}

For more advanced usage of random number generators the \cpp{#include<random>} header is provided. More advanced means that not only integer random number can be drawn and range can be provided. Listing~\ref{code:distrand} shows how to generate uniform distributed random numbers. Line~8 generates a random number device \cpp{std::random_device rd}\link{http://www.cplusplus.com/reference/random/random_device/}. Next, the engine for the random number generation is chosen. In this case the \cpp{mersenne_twister_engine}~\cite{matsumoto1998mersenne} is used by providing the random device as an argument \cpp{std::mt19937 gen(rd())}\link{http://www.cplusplus.com/reference/random/mersenne_twister_engine/}. Next the uniform distribution has to be specified by \cpp{std::uniform_int_distribution} for integer values and \cpp{std::uniform_real_distribution} for floating point numbers. In Line~12 the interval from 1 to 6 for integer numbers and in Line~14 for double numbers is specified. Line~15 shows how to get a random number by using the distribution by passing the engine as an argument \cpp{dis(gen)}.

\lstinputlisting[language=C++,caption={Example using the trivial random number generator.\label{code:distrand}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture2-distrandom.cpp}

\theendnotes

%----------------------------------------------------------------------------------------
\chapter{The C++ Standard Template Library (STL)}
\label{chapter:stl}
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
\section{Overview of the STL}
%----------------------------------------------------------------------------------------
Figure~\ref{fig:stl:components} shows the four components of the C++ Standard Template Library (STL). The main focus in this course is on the algorithm component, container component, and iterators component. The functions component provides the so--called \texttt{Functors}\link{https://www.geeksforgeeks.org/functors-in-cpp/}. A functor is an object, which is treated a function or a function pointer. The component iterators\link{https://en.cppreference.com/w/cpp/iterator} provides six iterators for working upon a sequence of values, \emph{e.g.}\ containers. The usage of iterators will be discussed in Section~\ref{ref:stl:iterators}. For the Algorithms component\link{https://en.cppreference.com/w/cpp/algorithm} following algorithm classes:
\begin{itemize}
\item Sorting\link{https://en.cppreference.com/w/cpp/algorithm/sort} - Ordering elements in a container with respect to their order,
\item Searching\link{https://en.cppreference.com/w/cpp/algorithm/search} - Searching for elements in a sorted array, and
\item STL algorithms - Provides algorithms, like finding the largest element (max\link{https://en.cppreference.com/w/cpp/algorithm/max}) in an container or compute the sum\link{https://en.cppreference.com/w/cpp/algorithm/accumulate} of all elements;
\end{itemize}
will be reviewed. All of these algorithm classes will be showcased on the container \cpp{std::vector} in Section~\ref{sec:containers}. For more details on the STL we refer to~\cite{o2017mastering,stepanov1995standard}, but remember learning C++ is like learning a new sportive activity, practicing (writing code) is essential to improve your skills.\\ 

\textcolor{azure}{Most important take away of this section is: 
\begin{itemize}
\item Never implement your own algorithm or container, if you can find it within the STL.
\item If you can not find it within the STL, think if you really need this feature.
\end{itemize}
}

\begin{figure}[tb]
    \centering
    \begin{tikzpicture}
      [mindmap,
      grow cyclic,
      every node/.style=concept,
      concept color=cadetgrey!40,
      level 1/.append style={sibling angle=360/4},
      level 2/.append style={sibling angle=37.5},
      ]
    \node [root concept] {STL}
        child{
          node    {Algorithms} 
          child { node {Sorting} }         
          child { node {Searching} }      
          child { node {STL algorithms} }
          child { node {Array algoritms} }
          child { node {Partion operaitons } }         
        }
        child{
          node    {Containers}
          child { node {Sequence containers}
			child{ node{\cpp{std::vector}} }
			child{ node{\cpp{std::list}} } 
			child{ node{\cpp{std::array}} }                     
           }
          child { node {Container adaptors } }
          child { node {Associative containers } }
          child { node {Unordered associative containers } }
        }
        child{
          node    {Functions}
        }
        child{
          node    {Iterators}
        }
        ;
    \end{tikzpicture}
    \caption{Overview of the C++ Standard Template Library (STL): Algorithms, Containers, Iterators, and Functions. This course will mainly focus on the Algorithms and Container components.}
    \label{fig:stl:components}
\end{figure}

%----------------------------------------------------------------------------------------
\section{Containers}
\index{STL!containers}
\index{containers}
\label{sec:containers}
%----------------------------------------------------------------------------------------
Before we look into the containers, we start with an example to showcase the need of containers. Let us assume we want to compute the average
\begin{align}
a = \frac{1}{n}\sum\limits_{i=1}^n i
\end{align}
of the number from one to $n$. Listing~\ref{code:average} sketches how to compute the average using the ingredients of the previous chapter. Only one new feature \cpp{std::setprecision}\link{https://en.cppreference.com/w/cpp/io/manip/setprecision} is a new feature provided by \cpp{#include <iomanip>} header and you should be able to understand this code. If you have any issues, we highly recommend to go back to the previous chapter and read one more time the section about loop statements, see Section~\ref{sec:iteration:statements}. With \cpp{std::setprecision(3)} it is specified that only three digits of the following floating point number are printed. For example if one wants to print \cpp{const long double pi = std::acos(-1.L);} and uses \cpp{std::setprecision(3)} only $3.14$ is printed. Thus, depending on the application the accuracy can be varied.\\

In this example multiple values are read from the standard input using \cpp{while (std::cin >> x)} in Line~9. The \cpp{while} statement reads a new value from the standard input device, stores it in the variable \cpp{x}, until the users types \cpp{\\n}, which corresponds to a line break, since the loop condition is \cpp{false}. However, if we want to compute the median of a list of elements, we need to store the elements, process them, and print the average. To store these elements, we will look into the \cpp{std::vector} container and the \cpp{#include<algorithm>} header. In Section~\ref{sec:stl:algorithms} an example to compute the average is provided, since we have all the needed ingredients studied. For more details we refer to~\cite[Chapter~3]{andrew2000accelerated}.  

\lstinputlisting[language=C++,caption={Computation of the average of the numbers from one to $n$.\label{code:average}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture2-average.cpp}

%----------------------------------------------------------------------------------------
\subsection{Vector}
\index{STL!vector}
\index{vector}
%----------------------------------------------------------------------------------------
The container \cpp{std::vector} represents an object to store an arbitrary amount of the same data types. From the mathematical point of view the \cpp{std::vector} is comparable to a vector
\begin{align}
\mathbf{v} = \{v_i \,\vert\, i=1,\ldots,n \} \text{ with } \mathbf{v}[i] = v_i \text{ and }  \vert v\vert = n\text{.} 
\end{align}
Note in C++ the elements in a vector start with index zero and the index of the last element is $n-1$ with a vector length of $n$. To initialize an empty vector with the name \cpp{values} the expression \cpp{std::vector<double> values;} is used. Between the parenthesis the data type of all elements of the vector is specified. In this case only \cpp{double} values can be stored in the vector. In this case the length of the vector \cpp{values.size()} will return zero and \cpp{values.empty()} will return \cpp{true} since the vector is empty with the meaning that there are not elements stored. In addition, a vector can be filled with values during its definition using \cpp{std::vector<double> v = {1, 2.5};}. In this case the length of the vector \cpp{values.size()} will return two and \cpp{values.empty()} will return \cpp{false}.\\

Let us write the computation of the average again using the \cpp{std::vector}. Listing~\ref{code:averagecontainers} shows the new implantation of the computation of the average (Listing~\ref{code:average}). In Line~7 the \cpp{std::vector} with the name \cpp{values} for storing \cpp{double} values is declared. In Line~11 with \cpp{values.push_back{x}} the value of \cpp{x} is inserted at the end of the vector. To replace the third element of the vector by the value $1.5$ the expression \cpp{values[3]=1.4} is used. To replace the last element with zero the expression \cpp{values[values.size()-1]=0} is used. To access the elements on the $i$-th index the expression \cpp{values[i]} is used. The first element is accessed using \cpp{values.first()} and the last element using \cpp{values.last()}. More details about iterators are discussed in Section~\ref{ref:stl:iterators}. The last element is deleted by using \cpp{values.pop_back()} and the $i$-th element by \cpp{values.erase(values.start()+i}.\\


In Line~14 the sum of all elements in the vector is computed by using \cpp{std::accumulate} from the Algorithms component. The first argument \cpp{values.begin()} and the second argument \cpp{values.end()} defines the range of the vector. Here, it is the full vector, but for example to keep out the first element of sum, one can use \cpp{values.begin()+1}. The third argument is the initial value of the sum. More details about the Algorithms will be studied in Section~\ref{sec:stl:algorithms}.

\lstinputlisting[language=C++,caption={Computation of the average of the numbers from one to $n$ using containers.\label{code:averagecontainers}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture2-averagecontainers.cpp}

%----------------------------------------------------------------------------------------
\subsection{Iterators}
\label{ref:stl:iterators}
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
\subsection{Array}
%----------------------------------------------------------------------------------------


%----------------------------------------------------------------------------------------
\subsection{List}
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
\section{Algorithms}
\index{STL!algorithms}
\index{algorithms}
\label{sec:stl:algorithms}
%----------------------------------------------------------------------------------------
In this section some of the algorithms provided by the STL are studied. For a complete list of all available algorithms we refer to\link{https://en.cppreference.com/w/cpp/algorithm}. The median for a sorted list of numbers $\mathbf{v}=\{v_i \vert i =1,\ldots,n\}$ is given as
\begin{align}
median = \begin{cases}
v[\frac{n}{2}] \text{ if } n \text{ is even} \\
\frac{1}{2}\left( v[\frac{n}{2}] + v[\frac{n}{2}-1] \right) \text{else}
\end{cases} \text{.}
\end{align}
To compute the median of a \cpp{std::vector}, we have to sort the vector first. The STL provides the \cpp{std::sort} algorithm in the \cpp{#include <algorithm>} header. Listings~\ref{code:median} shows the computation of the median using the STL. In Line~6 a new feature \cpp{typedef}\link{https://en.cppreference.com/w/cpp/language/typedef} to shorten long lines of codes is introduced. In that case we do not want to type each time \cpp{std::vector<double>:: size_type} to get the data type of the vector size and want to use \cpp{vec_sz} instead. Each time the compiler recognizes \cpp{vec_sz} it will replace it by the long form. This is a neat feature to make the code more readable.\\

Line~13 shows how to use sort the values stored in the \cpp{std::vector} in Line~9--12. one has to provide the range of the vector to the sort function. Note that the current values in the vector will be replaced by the sorted ones. To keep the unsorted valued, a copy of the vector can be obtained by the \cpp{std::copy}\link{https://en.cppreference.com/w/cpp/algorithm/copy} algorithm.\\

\lstinputlisting[language=C++,caption={Computation of the median using the sorting algorithm provided by the STL.\label{code:median}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture2-median.cpp}

Another example is to compute the sum of all elements of a \cpp{std::vector} using a \cpp{for} loop or using the \cpp{std::accumulate}\link{https://en.cppreference.com/w/cpp/algorithm/accumulate} provided by the \cpp{#include <numerics>}\link{https://en.cppreference.com/w/cpp/header/numeric} header. Listing~\ref{code:algorithms:showcase} shows how to compute the sum and some neat algorithms. To fill a vector with the values one to ten, the function \cpp{std::ito}\link{https://en.cppreference.com/w/cpp/algorithm/iota} in Line~8 is used instead of writing a for loop. In Line~12--13 the sum is computed using the loop and in Line~17 the sum computed using the STL. One can easily see that the code in Line~17 is shorter and easier to understand. Therefore, it is recommended to use the STL were possible. In line~25--29 the values of the vector are printed to the standard output stream using a \cpp{for} loop. In Line~32 instead of using the \cpp{for} loop, the expression \cpp{std::for_each}\link{https://en.cppreference.com/w/cpp/algorithm/for_each} provided by the \cpp{#include <algorithm>} header is used. This lien of code iterates over all elements in the vector and call the function \cpp{print} and passes each element to the function. Note that the function can have only one argument and its type has to match the type of the vector.\\

There are many more algorithms in the STL as shown here. These algorithms will be introduced in the reaming parts of the book, especially with the numerical examples in Chapter~\ref{part:numerical:examples}. We recommend to have a look in the algorithms to write more efficient and less confusing code.   


\begin{lstlisting}[language=c++,caption={Example for a function definition to compute the maximum of two numbers.\label{code:algorithms:showcase}},float,floatplacement=tb]
#include <vector> 
#include <iostream>
#include <numerics>
#include <algorithm>

void print(double v){
	std::cout << v << " ";
}

int main(){

std::vector<double> values (10);
std::iota(values.begin(), values.end(), 1);

//Compute the sum using a for loop
double sum = 0;
for( auto& v : values)
	sum += v;
std::cout << "Sum:" << sum << std::endl;

//Compute the sum using STL 
sum = std::accumulate((values.begin(), values.end(),0);
std::cout << "Sum:" << sum << std::endl;

//Check the result by printing the vector using a for loop
for( size_t i = 0 ; i < values.size(); i++)
	std::cout << values[i] << " ";
	std::cout << std::endl;

}

//Check the result by printing the vector using STL
std::for_each(values.begin(), values.end(), print);
\end{lstlisting}



%----------------------------------------------------------------------------------------
\section{Parallel Algorithms}
%\index{STL!algorithms}
%\index{algorithms}
%\label{sec:stl:algorithms}
%----------------------------------------------------------------------------------------




%----------------------------------------------------------------------------------------
\section{Numerical limits}
%----------------------------------------------------------------------------------------


\theendnotes
