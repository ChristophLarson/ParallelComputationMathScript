%\chapterimage{chapter_head_2.pdf} % Chapter heading image

%----------------------------------------------------------------------------------------
\chapter{Introduction C++}
%----------------------------------------------------------------------------------------
This chapter gives a brief introduction to the core features of the C++ language. However, the focus on this chapter is to introduce the C++ standard template library, see Section~\ref{chapter:stl}, which is essential to implement mathematical equations and algorithms. Therefore, we quickly look into these features as we need them to implement the numerical examples in Part~\ref{part:numerical:examples}. For more details we refer to
\begin{itemize}
\item \fullcite{andrew2000accelerated}
\end{itemize}
since this book gives an excellent pragmatic overview with a lot of examples. For even more C++ basics, we refer to
\begin{itemize}
\item \fullcite{stroustrup2014programming}.
\end{itemize}
%----------------------------------------------------------------------------------------
\section{History of C and C++}
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
\section{Getting started with C++}
%----------------------------------------------------------------------------------------
To begin with C++ programming, we look at a simple C++ program, the so-called ``Hello World'' example which most programming language start with. Listing~\ref{code:hello:world} shows this program and the first line in green a comment is shown. A  single-line comments always starts with \lstinline[language=C++]|//| and is used to explain the functionality of the program or the next lines of codes. It is also possible to use multi-line comments\endnote{\url{https://en.cppreference.com/w/cpp/comment}} by using \lstinline[language=C++]{/* */}. Comments are important to understand the program, especially if the code is shared with other collaborators. Fore more details we refer to~\cite{kernighan1974elements}.

The second line starts with a so-called include directive\endnote{\url{https://en.cppreference.com/w/cpp/preprocessor/include}} \lstinline[language=C++]{#include <iostream>}. This include directive is needed to include functionality of the C++ standard library, see Chpater~\ref{chapter:stl}, in our case we include the \lstinline|iostream| header to print the Hello World to the terminal, see Line 6.

The fourth line \lstinline[language=C++]{int main()} starts with the so-called Main function\endnote{\url{https://en.cppreference.com/w/cpp/language/main_function}} which is the entry point of the program and all code lines within are executed sequentially one by one. Every C++ which will be compiled to an executable needs exact one function called \lstinline[language=C++]|main| which have a integer \lstinline[language=C++]{int} as its return type. On most operation systems a return value of zero means that the program executed successfully and any other value indicates an failure. The second last line \lstinline[]|return| is the so--called return statement\endnote{\url{https://en.cppreference.com/w/cpp/language/return}} which has to match the return type in front of the \lstinline[language=C++]{int main()}.


\lstinputlisting[language=C++,caption={A simple C++ program, the so-called ``Hello World'' example, which most languages start with.\label{code:hello:world}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture1-main.cpp}

Once we have written the program, we have to compile the C++ code into an executable to run the code and print ``Hello world'' to the terminal. Note that there are plenty of C++ compilers\endnote{\url{https://en.wikipedia.org/wiki/List_of_compilers\#C++_compilers}} available, however this book will use the GNU Compiler Collection (GCC) for all examples. Line 1 in Listing~\ref{code:hello:world:compile} shows how to compile the file \lstinline[language=bash]|lecture1-1.cpp|, which contains the C++ code in Listing~\ref{code:hello:world}, to an executable. The GCC provides the \lstinline[language=bash]{g++} compiler to compile C++ code and the \lstinline[language=bash]{gcc} compiler to compile C code. As the first argument to the \lstinline[language=bash]{g++} compiler the file name of the C++ is provided and with the \lstinline[language=bash]|-o| option the name of the executable is specified. To run the generated executable, we type \lstinline[language=bash]|./lecture-1-1| in the terminal. Note for the basic usage of the Linux terminal we refer to~\cite{newham2005learning,robbins2016bash}.

\lstinputlisting[language=bash,caption={Compilation and execution of the C++ program.\label{code:hello:world:compile}},float,floatplacement=tb,firstline=2, lastline=3]{ParallelComputationMathExamples/chapter2/lecture1-main.sh}

\begin{exercise}
Download the example program\endnote{\url{https://github.com/diehlpkteaching/ParallelComputationMathExamples}} from GitHub and compile it with your favorite C++ compiler. After you ran the example you could try to modify it, for example you could print a different text or add a second line to the output.
\end{exercise}


%----------------------------------------------------------------------------------------
\section{Fundamental data types}
%----------------------------------------------------------------------------------------
\index{data types!fundamental}
In this section the fundamental data types\endnote{\url{https://en.cppreference.com/w/cpp/language/types}} provided by the C++ language are introduced. First, the numeric data types are introduced. To represent natural numbers $\mathbb{N}=\{0,1,2,\ldots \}$ the \lstinline[language=C++]|unsigned int| data type is available. To represent integer numbers $\mathbb{Z}=\{\ldots,-2,-1,0,1,2,\ldots \}$ the \lstinline[language=C++]|int| data type is available. For all these data types following options: \lstinline[language=C++]|short|, \lstinline[language=C++]|long|, and \lstinline[language=C++]|long long| are available. In the \cpp{#include <climits>}\link{https://en.cppreference.com/w/cpp/header/climits} header the minimal and maximal value of all integer data types are defined. For example the minimal value of \cpp{int} data type is given by \cpp{INT_MIN} and the maximal value by \cpp{INT_MAX}, respectively. For more details about the binary numeral system we refer to~\cite{gilli1965binary}. 

To represent real numbers $\mathbb{R}$ the \lstinline[language=C++]|float| data type and \lstinline[language=C++]|double| data type are available. In the \cpp{#include <cfloat>}\link{https://en.cppreference.com/w/cpp/header/cfloat} header the minimal and maximal value of all floating point data types are defined. For example the minimal value of \cpp{double} data type is given by \cpp{DBL_MIN} and the maximal value by \cpp{DBL_MAX}, respectively. 

Fore more details about the IEEE 474 standard how floating point numbers are represented in the computer we refer to~\cite{4610935,goldberg1991every}. Table~\ref{chapter2:table:datatypes} summarizes all the available numeric data types and there ranges. The next section shows how to get the range of the IEEE 474 standard how floating point numbers.

\begin{table}[h]
\centering
\begin{tabular}{lccc}
\toprule
Data type & Size (Bytes) & Min & Max \\\midrule
\multicolumn{4}{c}{Natural numbers $\mathbb{N}$ }\\\midrule
\lstinline[language=C++]|unsigned short int| & 2 & 0 & 65,535  \\ 
\lstinline[language=C++]|unsigned int| & 4 & 0 & 4,294,967,295 \\ 
\lstinline[language=C++]|unsigned long int| & 4 & 0 & 4,294,967,295 \\ 
\lstinline[language=C++]|unsigned long long int| & 8 & 0 & 8,446,744,073,709,551,615 \\ \midrule
\multicolumn{4}{c}{Integer numbers $\mathbb{Z}$ }\\\midrule
\lstinline[language=C++]|short int| & 2 & -32,768 & 32,768 \\
\lstinline[language=C++]|int| & 4 & -2,147,483,648 & 2,147,483,648 \\
\lstinline[language=C++]|long long int| & 8 & $-2^{63}$ & $2^{63}-1$ \\\midrule
\multicolumn{4}{c}{Real numbers $\mathbb{R}$ }\\\midrule
\lstinline[language=C++]|float| & 4 &  &  \\
\lstinline[language=C++]|double| & 8 &  &  \\
\bottomrule
\end{tabular} 
\caption{Overview of the fundamental numeric data types.}
\label{chapter2:table:datatypes}
\end{table}

To represent a boolean value $\mathbf{B}=\{0,1\}$ the \lstinline[language=C++]|bool| data type which has either one of the two values \lstinline[language=C++]|true| or \lstinline[language=C++]|false|. Note that the C++ STL offers \lstinline|std::complex|\endnote{\url{https://en.cppreference.com/w/cpp/numeric/complex}} for complex number $\mathbb{C}$, however, this one is not within the fundamental data types.

%----------------------------------------------------------------------------------------
\section{Statements and flow control}
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
\subsection{Iteration statements}
\label{sec:iteration:statements}
%----------------------------------------------------------------------------------------
\index{statements!iteration} For some applications, we have to repeat some operations multiple times. The C++ language provides the so-called iteration statements. There are two iteration statements, the \lstinline[language=C++]|for| loop and the \lstinline[language=C++]|while| loop, respectively. Let us look how to compute the sum of the numbers from one up ton $n$
\begin{align}
r = \sum\limits_{i=1}^n i\text{.}
\end{align}
The first option is using a \lstinline[language=C++]|for| loop statement\endnote{\url{https://en.cppreference.com/w/cpp/language/for}}\index{loop!for statement} which shown in Listing~\ref{code:for:loop}. Line 9 shows the \lstinline[language=C++]|for| loop statement with its three arguments. First, the so--called loop variable \lstinline[language=C++]{size_t i = 0} which is initialized to zero. Note that the loop variable is only defined within the loop's body (The part between the curly braces). Second, the so--called condition statement \lstinline[language=C++]{i < n} which means that the loop body is repeated until the variable $i$ is larger than $n$. The third statement manipulates the loop variable, in our case the loop variable is incremented by one after the loop body was executed once. Note that we use the \lstinline[language=C++]|for| loop statement, if we know how often we have to loop through the loop body in advance.


\lstinputlisting[language=C++,caption={Computation of the sum from one up to $n$ using the for loop statement. \label{code:for:loop}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture1-for.cpp}

The second option is using a \lstinline[language=C++]|while| loop statement\endnote{\url{https://en.cppreference.com/w/cpp/language/while}}\index{loop!while statement} which shown in Listing~\ref{code:while:loop}. Line 10 shows the \lstinline[language=C++]|while| loop statement with its one argument. This is the so-called condition statement  \lstinline[language=C++]{i < n} which means that the loop body is repeated until the variable $i$ is larger than $n$. Note in the previous example we had three arguments. Here, the loop variable is declared before the loop in Line 9 and the third statement is  in Line 13 where the loop variable is incremented by one in each iteration. Note that we use the \lstinline[language=C++]|while| loop statement, if we do not know the amount of iterations in advance. This example has shown that we can write every \lstinline[language=C++]|for| loop statement as a \lstinline[language=C++]|while| loop statement. For more details we refer to~\cite[Chapter~2]{andrew2000accelerated}.   


\lstinputlisting[language=C++,caption={Computation of the sum from one up to $n$ using the while loop statement..\label{code:while:loop}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture1-while.cpp}

\begin{exercise}
Define in your own words in which case you should use a \lstinline[language=C++]|for| loop statement and a \lstinline[language=C++]|while| loop statement. 
\end{exercise}

%----------------------------------------------------------------------------------------
\subsection{Selection statements}
%----------------------------------------------------------------------------------------
\index{statements!selection}
For some applications, we have to select different behavior of the code depending on conditions. Equation~\ref{eq:chapter2:if} shows how to compute the sum from one to $n$ with different cases for even and odd numbers, If the number is even the number keeps the same and for odd numbers the number is squared.
\begin{align}
r = \sum\limits_{i=1}^n f(i) \text{  with  } f(i) = 
\begin{cases}
i, \text{ if } i \text{ is even} \\
i^2, \text{ else}
\end{cases}
\label{eq:chapter2:if}
\end{align}
Listing~\ref{code:example-if} shows the implementation of Equation~\ref{eq:chapter2:if} using a \lstinline[language=c++]{for} loop. The skeleton of the \lstinline[language=c++]{for} loop is identical to the one in Listing~\ref{code:for:loop}, but the \lstinline[language=c++]{if} statement\endnote{\url{https://en.cppreference.com/w/cpp/language/if}} in Line 8 is added to switch between even and odd numbers. The \lstinline[language=c++]{if} statement takes exactly one argument, the so--called condition statement. If the statement is evaluated as \lstinline[language=c++]{true} the code line between \lstinline[language=c++]{if} and \lstinline[language=c++]{else} is selected.  If the statement is evaluated as \lstinline[language=c++]{false} the code line after \lstinline[language=c++]{else} is selected. Multiple lines of codes have to be between curly braces. It is also possible to use \lstinline[language=c++]{else if} after the first \lstinline[language=c++]{if}. \\

\lstinputlisting[language=C++,caption={Computation of the sum from one up to $n$ using the selection statement.\label{code:example-if}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture1-if.cpp}


The second selection statement is the \lstinline[language=c++]{switch} statement\endnote{\url{https://en.cppreference.com/w/cpp/language/switch}}. For example this statement can be used to execute different code branches depending on a single variable. Listing~\ref{code:example-switch} shows one example to write the name of the color to the standard output. In this case we use a enumeration \lstinline[language=c++]{enum}\endnote{\url{https://en.cppreference.com/w/cpp/language/enum}} to store the colors. The \lstinline[language=c++]{switch} takes one argument and execute the code between the matching \lstinline[language=c++]{case} and the following \lstinline[language=c++]{break}. For more details we refer to~\cite[Chapter~2]{andrew2000accelerated}.  


\lstinputlisting[language=C++,caption={Computation of the sum from one up to $n$ using the selection statement.\label{code:example-switch}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture1-switch.cpp}


%----------------------------------------------------------------------------------------
\section{Operators}
%----------------------------------------------------------------------------------------
\index{Operators}
For the example in Listing~\ref{code:for:loop} we have seen the operator \lstinline[language=C++]|i<n| which is a so--called comparison operator. Next to the comparison operators, C++ language has following operators\endnote{\url{https://en.cppreference.com/w/cpp/language/operator_precedence}}:
\begin{itemize}
\item Comparison operators, see Table~\ref{sec:1:tab:operator:comp},
\item Arithmetic operators, see Table~\ref{sec:1:tab:operator:arithmetic},
\item Logical operators, see Table~\ref{sec:1:tab:operator:logical}, and
\item Assignment operators, see Table~\ref{sec:1:tab:operator:assign},
\end{itemize}
 logical operators, arithmetic, and assignment.

\begin{table}[p]
\centering
\begin{tabular}{clll}
\toprule
Operator & Name  & Example \\ 
\midrule
\lstinline|==| & Equal to & \lstinline|x==y|\\ 
\lstinline|!=| & Not equal & \lstinline|x!=y|\\ 
\lstinline|>| & Greater than & \lstinline|x > y|\\ 
\lstinline|<| & Less than & \lstinline|x < y|\\ 
\lstinline|>=| & Greater than or equal & \lstinline|x >= y|\\ 
\lstinline|<=| & Less than or equal & \lstinline|x <= y|\\ 
\bottomrule 
\end{tabular} 
\caption{Comparison operators}
\label{sec:1:tab:operator:comp}
\index{Operators!comparison}
\end{table}

\begin{table}[p]
\centering
\begin{tabular}{clll}
\toprule
Operator & Name & Description & Example \\ 
\midrule
\lstinline|+| & Addition & Computes the sum of two values & $2+2=4$ \\ 
\lstinline|-| & Subtraction  & Computes the difference of two values & $5-3=2$ \\ 
\lstinline|/| & Division & Divides two values & $6/2=3$ \\ 
\lstinline|*| & Multiplication & Multiplies two values & $2\times2=4$ \\ 
\lstinline|%| & Modulo &  	Returns the division remainder & \lstinline|2%1=0| \\ 
\lstinline|++| & Increments & Add plus one to the value & \lstinline|1++=2|\\ 
\lstinline|--| & Decrements & Subtract one of the value & \lstinline|1--=0|\\ 
\bottomrule 
\end{tabular} 
\caption{Arithmetic operators}
\label{sec:1:tab:operator:arithmetic}
\index{Operators!arithmetic}
\end{table}


\begin{table}[p]
\centering
\begin{tabular}{clll}
\toprule
Operator & Name & Description & Example \\ 
\midrule
\lstinline|&&| & Logical and & Returns \lstinline|true| if both statements are true  & \lstinline| x > 5 && x < 10| \\ 
\lstinline|||| & Logical or  & Returns \lstinline|true| if one statement is true & \lstinline| x > 5 || y < 10| \\ 
\lstinline|!| & Logical not &  Inverse the statement & \lstinline| !(x > 5 && x < 10)| \\ 
\bottomrule 
\end{tabular} 
\caption{Logical operators}
\label{sec:1:tab:operator:logical}
\index{Operators!logical}
\end{table}


\begin{table}[p]
\centering
\begin{tabular}{clll}
\toprule
Operator & Name & Example & Equivalent  \\ 
\midrule
\lstinline|=| & Assignment &   \lstinline| x = 5| &   \lstinline| x = 5 | \\ 
\lstinline|+=| & Plus equal  & \lstinline| x+= 5|  & \lstinline| x = x + 5 | \\ 
\lstinline|-=| & Minus equal & \lstinline| x-= 5|  & \lstinline| x = x - 5 | \\ 
\lstinline|*=| & Multiplication equal &  \lstinline| x*= 5| & \lstinline| x= x * 5| \\ 
\lstinline|/=| & Division equal &  \lstinline| x/= 5| & \lstinline| x= x / 5| \\ 
\lstinline|%=| & Modulo equal &  \lstinline| x%= 5| & \lstinline| x = x % 5| \\ 
\bottomrule 
\end{tabular} 
\caption{Assignment operators}
\label{sec:1:tab:operator:assign}
\index{Operators!assignment}
\end{table}

\begin{exercise}
Write a small C++ program using selection statements and operators to determine if a given year is a lap year. Following logical statements should be implemented: 
\begin{itemize}
	\item   If year is divided by 4 but not by 100, then it is a leap year.
    \item If year is divided by both 100 and 400, then it is a leap year.
    \item If year is divided by 400, then it is a leap year.
    \item And in all other cases, it is not a leap year.
\end{itemize}
\end{exercise}

%----------------------------------------------------------------------------------------
\subsection{Operator overloading}
%----------------------------------------------------------------------------------------


%----------------------------------------------------------------------------------------
\section{Structuring source code}
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
\subsection{Functions}
\index{functions}
\index{structure!function}
\label{sec:functions}
%----------------------------------------------------------------------------------------
To use code again and do not have to repeat code blocks multiple times, one can use function definitions\link{https://en.cppreference.com/w/c/language/function_definition}. Listings~\ref{code:functions:max} shows the definition of the function \cpp{max}. In Line~1 the return type \cpp{int} of the function is defined which means that this function will return one integer value. This is happening in Line~3 using the \cpp{return}\link{https://en.cppreference.com/w/cpp/language/return} keyword. If the function has no return value, the keyword \cpp{void} is used. In Line~1 the name of the function\link{https://en.cppreference.com/w/cpp/language/functions} \cpp{max} is defined and in the parentheses the function arguments are provided separated by commas. In this example two integer values with the name \cpp{a} and \cpp{b} are provided. For the return value, a short form of the \cpp{if} statement. the so--called conditional operator\link{https://en.cppreference.com/w/cpp/language/operator_other\#Conditional_operator}, is provided which means if $a>b$ return $a$ and else return $b$. The function is called as \cpp{double result = max(5,7.7)}.   \\

\begin{lstlisting}[language=c++,caption={Example for a function definition to compute the maximum of two numbers.\label{code:functions:max}},float,floatplacement=tb]
int max(int a, int b)
{
return a>b?a:b;
}
\end{lstlisting}

Function are defined between \cpp{#include} and \cpp{int main (void)} in the source code file. Listing~\ref{code:example-function} shows the usage of a function definition for the example in Equation~\ref{eq:chapter2:if}. For more details we refer to~\cite[Chapter~4]{andrew2000accelerated}.

\lstinputlisting[language=C++,caption={Example for a function definition to compute Equation~\ref{eq:chapter2:if}.\label{code:example-function}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture2-function.cpp}


%----------------------------------------------------------------------------------------
\subsection{Struct}
\index{struct}
\index{structure!struct}
%----------------------------------------------------------------------------------------
In some case, we like to group data, for example to represent a vector $v=(x,y,z)^T\in \mathbb{R}^3$. Here, the \cpp{struct}\link{https://en.cppreference.com/w/c/language/struct} expression is provided. Note that the struct was introduced in the C language and its companion in the C++ language is the \cpp{class} expression. However, to make the C language a subset of the C++ language, the \cpp{struct} is still available. Listing~\ref{code:struct} shows the struct with the three variables for each direction of the vector space. To declare a vector, we just write \cpp{struct vector v} to have an vector with the name \cpp{v} and to initialize the vector with the unit vector \cpp{struct vector v = \{1,1,1\}}\link{https://en.cppreference.com/w/c/language/struct_initialization}. To access the x component of the vector, we write \cpp{v.x} and to assign a new value the expression \cpp{v.x=42} is used. For more details we refer to~\cite[Chapter~4]{andrew2000accelerated}.

%----------------------------------------------------------------------------------------
\subsubsection{Constructor}
\index{constructor}
\index{structure!constructor}
%----------------------------------------------------------------------------------------
Each \cpp{struct} and \cpp{class} has a default constructor\link{https://en.cppreference.com/w/cpp/language/default_constructor}. However, one can overload the constructor for example to initialize the vector a zero $v=\{0,0,0\}$. Line~11 shows the constructor to initialize an zero vector. The constructor is like a function without the \cpp{return} option with the same name as the \cpp{struct} and \cpp{class}. As the constructor arguments the three vector components are given. Note that we assign the value zero to all of them. In Line~12 we assign the argument's values to the variables within the struct by using \cpp{x(x)} which means that we assign the \cpp{double x} of the \cpp{struct} the value of the \cpp{x} in the parentheses. Now we can initialize the \cpp{struct} in two different ways. First, using \cpp{struct vector v;} will result in $v=\{0,0,0\}$ since we assign zero to all the values. Second, using \cpp{struct vector v = vector(1,2,3);} will result in $v=\{1,2,3\}$. For more details we refer to~\cite[Chapter~4]{andrew2000accelerated}.

%----------------------------------------------------------------------------------------
\subsubsection{Member function}
\index{member function}
\index{structure! member function}
%----------------------------------------------------------------------------------------
A often used task is to compute the length of a vector $\sqrt{x^2+y^2+z^2}$, thus we want to add this function to the \cpp{struct vector} to call \cpp{norm()} to compute the norm, see Line~15. The syntax for member functions is the same as for functions. see Section~\ref{sec:functions}. The main difference is that the function definition is between the parentheses of the \cpp{struct} definition. For more details we refer to~\cite[Chapter~4]{andrew2000accelerated}.

\begin{lstlisting}[language=c++,caption={Example for a structure for a three dimensional vector.\label{code:struct}},float,floatplacement=tb]
#include <cmath>

struct vector 
{
// vector components
double x;
double y;
double z;

// constructor
vector(double x=0, double y=0, double z=0)
	x(x), y(y), z(z) {}

// member function to compute the vector's length
double norm(){
	return std::sqrt(x*x+y*y+z*z);
}
}
\end{lstlisting}



%----------------------------------------------------------------------------------------
\subsection{Classes}
%----------------------------------------------------------------------------------------
For more details we refer to~\cite[Chapter~9]{andrew2000accelerated}.


%----------------------------------------------------------------------------------------
\section{Generic programming}
%----------------------------------------------------------------------------------------
In some cases, we need to write the same function for different data types, \emph{e.g.}\ \cpp{double} and \cpp{float}, see Listing~\ref{code:generix:example}. We would need to write the same function for all data types. Thus, we will produce the same computation multiple time and have too much redundant code.If there is an error in the computation, we would have to correct it for all of the functions. Function templates\link{https://en.cppreference.com/w/cpp/language/function_template}\index{function~template} are provided by the C++ language. Listing~\ref{code:generix:example} shows starting at Line~11 how to combine the previous two function into one. In Line~11 the expression \cpp{typename} indicates that we define a function template and within the parentheses the \cpp{typename T} is defined which is a placeholder for the explicit data type. For the remaining function definition everything keeps the same and only the specific data type, \emph{e.g.}\ \cpp{double} and \cpp{float}, is replaced by \cpp{T}. Now, the function is used as \cpp{add<double>} or \cpp{add<float>} or \cpp{add<int>} for the various data types without explicit implementing all of them. This is a neat feature to reduce the amount of code.\\

\begin{lstlisting}[language=c++,caption={Example for the usage function templates.
\label{code:generix:example}},float,floatplacement=tb]
// Definition of multiple functions
double add(double a, double b) {
	return a + b;
}

float add(float a, float b) {
	return a + b;
}

// Function template
template<typename T>
T add(T a, Tb){
	return a+b;
}
\end{lstlisting}

The same is possible for \cpp{struct} and \cpp{classes} by adding \cpp{template<typename T>}\link{https://en.cppreference.com/w/cpp/language/templates} above the definition and using the \cpp{T} instead of \cpp{double} as in Listing~\ref{code:struct}.  Now, the function is used as \cpp{struct vector <double> v;} or \cpp{struct vector<float> v;} or \cpp{struct vector<int> v;} for the various data types without explicit implementing all of them. For the function \cpp{norm()} there is no need to use \cpp{template<typename T>} again and the return type \cpp{double} is replaced by \cpp{T}. Fore more details, we refer to~\cite{josuttis2003c++}. For further watching, we recommend the C++ Lecture 2 - Template Programming 2\link{https://www.youtube.com/watch?v=iU3wsiJ5mts} and C++ Lecture 4 - Template Meta Programming\link{https://www.youtube.com/watch?v=6PWUByLZO0g}.

\begin{exercise}
Use the \cpp{struct} in Listing~\ref{code:struct} and make it a generic one by adding the \cpp{template<typename T>} and replace all \cpp{double} by \cpp{T}.
\end{exercise}

\newpage
\theendnotes

%----------------------------------------------------------------------------------------
\chapter{The C standard library}
\label{chapter:cpp:lib}
%----------------------------------------------------------------------------------------
The ANSI C standard\link{http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf}\index{ANSI C} is the specification for the C standard library (libc). The C standard library provides following functionality
\begin{itemize}
\item Handling set of characters in the \cpp{#include <cstring>} header,
\item handling times and dates in the \cpp{#include <ctime>} header,
\item Support of complex numbers in the \cpp{#include <ccomplex>},
\item Mathematical functions in the \cpp{#include <cmath>} header,
\item Limits of integer types in the \cpp{#include <climits>} header,
\end{itemize}
and many more features. However, these are the features we will use most in this course. For more details, we refer to~\cite{josuttis2012c++}.

%----------------------------------------------------------------------------------------
\section{Strings}
\index{libc!string}
\index{string}
%----------------------------------------------------------------------------------------
The STL provides the class \lstinline[language=C++]{string}\endnote{\url{http://www.cplusplus.com/reference/string/string/}} to store sequences of characters. For the usage of this class the header \lstinline[language=c++]{#include <string>} has to be added to the cpp file to make \lstinline[language=c++]{std::string} available. Listing~\ref{code:strings} shows how to use the string class to write a set of characters to standard output stream\endnote{\url{http://www.cplusplus.com/reference/iostream/cout/?kw=cout}} \lstinline[language=c++]{std::cout} and read them from standard input stream\endnote{\url{http://www.cplusplus.com/reference/iostream/cin/?kw=cin}} \lstinline[language=c++]{std::cin}. To use these functionality the \lstinline[language=c++]{#include <iostream>} header is needed. \index{iostream!cin}\index{iostream!cout} \\

In Line~7 the set of characters \lstinline[language=c++]{"Please enter your name: "} is written to the standard output stream using the operator \lstinline[language=c++]{<<}. In Line~9 a string object with the identifier \lstinline[language=c++]{name} is declared. All variables have a name \lstinline[language=c++]{name} and a type  \lstinline[language=c++]{std::string}. Since the variable is declared but not initialized yet, the variable is empty or a null string. The assignment operator \lstinline[language=c++]{=} is used to initialize the variable with a set of characters  \lstinline[language=c++]{std::string name = "Mike"}. In Line~10 the variable is initialized with the content provided by the standard input stream \lstinline[language=c++]{std::cin} and the \lstinline[language=c++]{>>} operator. In Line~12 the content of the variable is written to the standard output stream. Note that you can concatenate strings using the \lstinline[language=c++]{>>} operator multiple times. To generate a line break the statement \lstinline[language=c++]{std::endl} is used. Note that we only handled the basis features here, since these are necessary for the purpose of this course. For more details we refer to~\cite[Chapter~1]{andrew2000accelerated}.


\lstinputlisting[language=C++,caption={Example reading and writing strings.\label{code:strings}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture1-string-io.cpp}


%----------------------------------------------------------------------------------------
\section{Random number generation}
\index{libc!random number generation}
\index{random number generation}
\label{sec:random:numbers}
%----------------------------------------------------------------------------------------
For some applications, \emph{e.g.}\ Monte Carlo methods, see Chapter~\ref{sec:monte:carlo}, random numbers are essential. The trivial way to generate a integer random number in the range of zero and \cpp{RAND_MAX} is to use \cpp{std::rand}\link{http://www.cplusplus.com/reference/cstdlib/rand/} provided by the \cpp{#include <cstdlib>} header. Listing~\ref{code:srand} shows a small example to generate a random number. Note that one has to provide a seed to the random number generator to get a different random numbers each time the program is executed. One way to do so, is to use the current time \cpp{std::time(0)}\link{http://www.cplusplus.com/reference/ctime/time/?kw=time} provided by the \cpp{#include <ctime>} header. Line~10 shows how to use the current time passed as an argument \cpp{std::srand(std::time(0))} as a seed for the random number generator. Line~\mbox{12} shows how to get one random number. Note that the seed has to be set only once, but always before any random number is drawn.\\

\lstinputlisting[language=C++,caption={Example using the trivial random number generator.\label{code:srand}},float,floatplacement=tbp]{ParallelComputationMathExamples/chapter2/lecture2-random.cpp}

For more advanced usage of random number generators the \cpp{#include<random>} header is provided. More advanced means that not only integer random number can be drawn and range can be provided. Listing~\ref{code:distrand} shows how to generate uniform distributed random numbers. Line~8 generates a random number device \cpp{std::random_device rd}\link{http://www.cplusplus.com/reference/random/random_device/}. Next, the engine for the random number generation is chosen. In this case the \cpp{mersenne_twister_engine}~\cite{matsumoto1998mersenne} is used by providing the random device as an argument \cpp{std::mt19937 gen(rd())}\link{http://www.cplusplus.com/reference/random/mersenne_twister_engine/}. Next the uniform distribution has to be specified by \cpp{std::uniform_int_distribution} for integer values and \cpp{std::uniform_real_distribution} for floating point numbers. In Line~12 the interval from 1 to 6 for integer numbers and in Line~14 for double numbers is specified. Line~15 shows how to get a random number by using the distribution by passing the engine as an argument \cpp{dis(gen)}.

\lstinputlisting[language=C++,caption={Example using the trivial random number generator.\label{code:distrand}},float,floatplacement=tbp]{ParallelComputationMathExamples/chapter2/lecture2-distrandom.cpp}

%----------------------------------------------------------------------------------------
\section{Numerical limits}
\index{numerical limits}
%----------------------------------------------------------------------------------------
Since the limits of the numerical data types depend on the various things, the \cpp{#include <limits>} header\link{https://en.cppreference.com/w/cpp/types/numeric_limits} is available to access this information. For the integer data types, the function \cpp{std::numeric_limits<unsigned int>::min()} is provided to receive the smallest finite value and the function \cpp{std::numeric_limits<unsigned int>::max()} the largest finite value of the \cpp{unsigned int} data type.\\

For floating point numbers, two additional values are accessible, see Listing~\ref{code:numerical:limits}. In Line~8 the rounding error \cpp{std::numeric_limits<double>::round_error()}\link{https://en.cppreference.com/w/cpp/types/numeric_limits/round_error} which returns the maximum rounding error of
the given floating-point type is shown. In Line~9 the value epsilon \cpp{std::numeric_limits<double>::epsilon()}\link{https://en.cppreference.com/w/cpp/types/numeric_limits/epsilon} which is the difference between 1.0 and the next representable value of the given floating-point type is obtained. Fore more details about the IEEE 474 standard how floating point numbers are represented in the computer we refer to~\cite{4610935,goldberg1991every}. The next two lines of code show how to access the minimal and maximal value.


\lstinputlisting[language=C++,caption={Example accessing the numerical limits of floating point types.\label{code:numerical:limits}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture3-limits2.cpp}


%----------------------------------------------------------------------------------------
\section{Reading and writing files}
%----------------------------------------------------------------------------------------
For numerical simulations, it is essential to read files, \emph{e.g.}\ configuration files, and store their values or write the simulation results to permanent storage. First, we look into how to read the content of a file line by line. To do so, the \cpp{ifstream}\link{https://en.cppreference.com/w/cpp/io/basic_ifstream} provided by the \cpp{#include <fstream>}\link{https://en.cppreference.com/w/cpp/header/fstream} header. Listing~\ref{code:io:reading} shows how to read the file's content \cpp{"example.txt"} line by line. In Line~7 a \cpp{ifstream} with the name \cpp{myfile} is declared. With the parentheses its constructor is called and the parameter is the file name of the file we want to open. Note that we assume that the file is located next to the cpp file. In Line~8 we check if the file could be opened successful. In that case the function \cpp{is_open()}\link{https://en.cppreference.com/w/cpp/io/basic_fstream/is_open} will return \cpp{true}. In line~10 the function \cpp{getline}\link{https://en.cppreference.com/w/cpp/string/basic_string/getline} is called to access the each line of the file. The first argument is the \cpp{ifstream} and the second argument is a \cpp{std::string} where the line of the file is stored. Each time the function is called there is new content in the argument \cpp{line}. If there is no next line. the function returns \cpp{false} and the \cpp{while} loop stops. In Line~16 the \cpp{ifstream} is closed by calling the \cpp{close()}\link{https://en.cppreference.com/w/cpp/io/basic_ifstream/close} function.\\

\lstinputlisting[language=C++,caption={Example for reading the content of file "example.txt" line by line.\label{code:io:reading}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture3-reading.cpp}

\begin{exercise}
Instead of printing the file content to the standard output device, store each line of the file in a \cpp{std::vector<string>}.
\end{exercise}
\vspace{0.25cm}

Second, we look into how to write the text \cpp{"Writing this to a file"} into the file \cpp{"example.txt"}, see Listing~\ref{code:io:writing}. In Line~6 the \cpp{std::ofstream}\link{https://en.cppreference.com/w/cpp/io/basic_ostream} is declared. In Line~7 the function \cpp{open()}\link{https://en.cppreference.com/w/cpp/io/basic_ofstream/open} is called. The first argument is the file name of the file to create. The second argument is the file mode \cpp{std::ios::out}\link{https://en.cppreference.com/w/cpp/io/ios_base/openmode}. In Line~8 the operator \cpp{<<} is used to write the string to the file. By using \cpp{"\n"} we indicate a line break and all content after will be in a new line of the file. In Line~9 the file is closed by calling the \cpp{close()}\link{https://en.cppreference.com/w/cpp/io/basic_ofstream/close} method.

\begin{exercise}
Instead writing one string to the file, write all string in a \cpp{std::vector<string>} to the file with each string in a new line.
\end{exercise}

\lstinputlisting[language=C++,caption={Example for writing to the file "example.txt".\label{code:io:writing}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture3-writing.cpp}. 


\newpage
\theendnotes

%----------------------------------------------------------------------------------------
\chapter{The C++ Standard Template Library (STL)}
\label{chapter:stl}
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
\section{Overview of the STL}
\index{STL}
%----------------------------------------------------------------------------------------
Figure~\ref{fig:stl:components} shows the four components of the C++ Standard Template Library (STL). The main focus in this course is on the algorithm component, container component, and iterators component. The functions component provides the so--called \texttt{Functors}\link{https://www.geeksforgeeks.org/functors-in-cpp/}. A functor is an object, which is treated a function or a function pointer. The component iterators\link{https://en.cppreference.com/w/cpp/iterator} provides six iterators for working upon a sequence of values, \emph{e.g.}\ containers. The usage of iterators will be discussed in Section~\ref{ref:stl:iterators}. For the Algorithms component\link{https://en.cppreference.com/w/cpp/algorithm} following algorithm classes:
\begin{itemize}
\item Sorting\link{https://en.cppreference.com/w/cpp/algorithm/sort} - Ordering elements in a container with respect to their order,
\item Searching\link{https://en.cppreference.com/w/cpp/algorithm/search} - Searching for elements in a sorted array, and
\item STL algorithms - Provides algorithms, like finding the largest element (max\link{https://en.cppreference.com/w/cpp/algorithm/max}) in an container or compute the sum\link{https://en.cppreference.com/w/cpp/algorithm/accumulate} of all elements;
\end{itemize}
will be reviewed. All of these algorithm classes will be showcased on the container \cpp{std::vector} in Section~\ref{sec:containers}. For more details on the STL we refer to~\cite{o2017mastering,stepanov1995standard}, but remember learning C++ is like learning a new sportive activity, practicing (writing code) is essential to improve your skills. For further watching, we recommend the C++ Lecture 1 - The Standard Template Library\link{https://www.youtube.com/watch?v=asGZTCR53KY&list=PL7vEgTL3FalY2eBxud1wsfz8OKvE9sd_z}.\\ 

\textcolor{azure}{Most important take away of this section is: 
\begin{itemize}
\item Never implement your own algorithm or container, if you can find it within the STL.
\item If you can not find it within the STL, think if you really need this feature.
\end{itemize}
}

\begin{figure}[tb]
    \centering
    \begin{tikzpicture}
      [mindmap,
      grow cyclic,
      every node/.style=concept,
      concept color=cadetgrey!40,
      level 1/.append style={sibling angle=360/4},
      level 2/.append style={sibling angle=37.5},
      ]
    \node [root concept] {STL}
        child{
          node    {Algorithms} 
          child { node {Sorting} }         
          child { node {Searching} }      
          child { node {STL algorithms} }
          child { node {Array algoritms} }
          child { node {Partion operaitons } }         
        }
        child{
          node    {Containers}
          child { node {Sequence containers}
			child{ node{\cpp{std::vector}} }
			child{ node{\cpp{std::list}} } 
			child{ node{\cpp{std::array}} }                     
           }
          child { node {Container adaptors } }
          child { node {Associative containers } }
          child { node {Unordered associative containers } }
        }
        child{
          node    {Functions}
        }
        child{
          node    {Iterators}
        }
        ;
    \end{tikzpicture}
    \caption{Overview of the C++ Standard Template Library (STL): Algorithms, Containers, Iterators, and Functions. This course will mainly focus on the Algorithms and Container components.}
    \label{fig:stl:components}
\end{figure}

%----------------------------------------------------------------------------------------
\section{Containers}
\index{STL!containers}
\index{containers}
\label{sec:containers}
%----------------------------------------------------------------------------------------
Before we look into the containers, we start with an example to showcase the need of containers. Let us assume we want to compute the average
\begin{align}
a = \frac{1}{n}\sum\limits_{i=1}^n i
\end{align}
of the number from one to $n$. Listing~\ref{code:average} sketches how to compute the average using the ingredients of the previous chapter. Only one new feature \cpp{std::setprecision}\link{https://en.cppreference.com/w/cpp/io/manip/setprecision} is a new feature provided by \cpp{#include <iomanip>} header and you should be able to understand this code. If you have any issues, we highly recommend to go back to the previous chapter and read one more time the section about loop statements, see Section~\ref{sec:iteration:statements}. With \cpp{std::setprecision(3)} it is specified that only three digits of the following floating point number are printed. For example if one wants to print \cpp{const long double pi = std::acos(-1.L);} and uses \cpp{std::setprecision(3)} only $3.14$ is printed. Thus, depending on the application the accuracy can be varied.\\

In this example multiple values are read from the standard input using \cpp{while (std::cin >> x)} in Line~9. The \cpp{while} statement reads a new value from the standard input device, stores it in the variable \cpp{x}, until the users types \cpp{\\n}, which corresponds to a line break, since the loop condition is \cpp{false}. However, if we want to compute the median of a list of elements, we need to store the elements, process them, and print the average. To store these elements, we will look into the \cpp{std::vector} container and the \cpp{#include<algorithm>} header. In Section~\ref{sec:stl:algorithms} an example to compute the average is provided, since we have all the needed ingredients studied. For more details we refer to~\cite[Chapter~3]{andrew2000accelerated}.  

\lstinputlisting[language=C++,caption={Computation of the average of the numbers from one to $n$.\label{code:average}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture2-average.cpp}

%----------------------------------------------------------------------------------------
\subsection{Vector}
\index{STL!vector}
\index{vector}
%----------------------------------------------------------------------------------------
The container \cpp{std::vector} represents an object to store an arbitrary amount of the same data types. From the mathematical point of view the \cpp{std::vector} is comparable to a vector
\begin{align}
\mathbf{v} = \{v_i \,\vert\, i=1,\ldots,n \} \text{ with } \mathbf{v}[i] = v_i \text{ and }  \vert v\vert = n\text{.} 
\end{align}
Note in C++ the elements in a vector start with index zero and the index of the last element is $n-1$ with a vector length of $n$. To initialize an empty vector with the name \cpp{values} the expression \cpp{std::vector<double> values;} is used. Between the parenthesis the data type of all elements of the vector is specified. In this case only \cpp{double} values can be stored in the vector. In this case the length of the vector \cpp{values.size()} will return zero and \cpp{values.empty()} will return \cpp{true} since the vector is empty with the meaning that there are not elements stored. In addition, a vector can be filled with values during its definition using \cpp{std::vector<double> v = {1, 2.5};}. In this case the length of the vector \cpp{values.size()} will return two and \cpp{values.empty()} will return \cpp{false}.\\

Let us write the computation of the average again using the \cpp{std::vector}. Listing~\ref{code:averagecontainers} shows the new implantation of the computation of the average (Listing~\ref{code:average}). In Line~7 the \cpp{std::vector} with the name \cpp{values} for storing \cpp{double} values is declared. In Line~11 with \cpp{values.push_back{x}} the value of \cpp{x} is inserted at the end of the vector. To replace the third element of the vector by the value $1.5$ the expression \cpp{values[3]=1.4} is used. To replace the last element with zero the expression \cpp{values[values.size()-1]=0} is used. To access the elements on the $i$-th index the expression \cpp{values[i]} is used. The first element is accessed using \cpp{values.first()} and the last element using \cpp{values.last()}. More details about iterators are discussed in Section~\ref{ref:stl:iterators}. The last element is deleted by using \cpp{values.pop_back()} and the $i$-th element by \cpp{values.erase(values.start()+i}.\\


In Line~14 the sum of all elements in the vector is computed by using \cpp{std::accumulate} from the Algorithms component. The first argument \cpp{values.begin()} and the second argument \cpp{values.end()} defines the range of the vector. Here, it is the full vector, but for example to keep out the first element of sum, one can use \cpp{values.begin()+1}. The third argument is the initial value of the sum. More details about the Algorithms will be studied in Section~\ref{sec:stl:algorithms}. \\

Compared to other containers, \emph{e.g.}\ \cpp{std::list}, the \cpp{std::vector} is designed for
\begin{enumerate}
\item Are sufficient for small amount of elements. A good estimate is around 7000 elements,
\item Are optimized to access elements arbitrary, and
\item Performs well adding one element by the time to the end of the vector.
\end{enumerate}
For example the complexity for inserting or removing an element in a vector is $\mathcal{O}(n^2)$ and for the container \cpp{std::list} the complexity is $\mathcal{O}(n)$~\cite{michalewicz2013genetic,knuth1997art}.

\lstinputlisting[language=C++,caption={Computation of the average of the numbers from one to $n$ using containers.\label{code:averagecontainers}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture2-averagecontainers.cpp}


%----------------------------------------------------------------------------------------
\subsection{List}
\index{list}
\index{STL!list}
%----------------------------------------------------------------------------------------
Depending on the use case next to the \cpp{std::vector} container, the \cpp{std::list} container is available. The \cpp{std::list} container is provided by the \cpp{#include <list>} header. The usage of this container is similar to the \cpp{std::vector} and one can just replace \cpp{std::vector} by \cpp{std::list} in the code. Therefore, we will not provide any source code example here, since you can just look on them in the previous section. Compared to other containers, \emph{e.g.}\ \cpp{std::vector}, the \cpp{std::list} is designed for
\begin{enumerate}
\item Are slower for small amount of elements, and
\item Are optimized to insert and delete elements anywhere.
\end{enumerate}
For example the complexity for inserting or removing an element in a vector is $\mathcal{O}(n^2)$ and for the container \cpp{std::list} the complexity is $\mathcal{O}(n)$~\cite{michalewicz2013genetic,knuth1997art}.

%----------------------------------------------------------------------------------------
\subsection{Array}
%----------------------------------------------------------------------------------------


%----------------------------------------------------------------------------------------
\subsection{Iterators}
\label{ref:stl:iterators}
%----------------------------------------------------------------------------------------
Iterators\index{iterator} provided by the \lstinline|\#include<iterator>|\link{https://en.cppreference.com/w/cpp/header/iterator} header are pointing to some specific element, \emph{e.g.}\ \cpp{std::array} or \cpp{std::vector}, and provides some fast way to iterator over all elements in the range. As the example, we use the a vector \cpp{std::vector<int> v = \{1,2,3,4,5\};} and to access the first element \cpp{v.begin()}\link{https://www.cplusplus.com/reference/iterator/begin/} and to access the last element \cpp{v.end()}\link{https://www.cplusplus.com/reference/iterator/end/} is used. For the algorithms in the next Section, we use these for example to sort \cpp{std::sort(v.begin(),s.end(),std::greater<int>()}\link{https://en.cppreference.com/w/cpp/utility/functional/greater} from the largest to the lowest number. We can also use \cpp{v.next()}\link{http://www.cplusplus.com/reference/iterator/next/} to get the next element and \cpp{v.prev()}\link{http://www.cplusplus.com/reference/iterator/prev/} to get the previous element.\\

Using iterators, we can do advanced iterating over vectors, see Listing~\ref{code:for:iterator}. In Line~9 a constant iterator \cpp{std::vector<int>::const_iter} and assign the first element of the vector to it. For the \cpp{for} loop in Section~\ref{sec:iteration:statements} this would be equivalent to loop variable \cpp{size_t i = 0}. In Line~11 we use the not equal operator \cpp{iter != values.end()} as the condition statement. The equivalent for the \cpp{for} loop would be \cpp{ i < vector.size()}. In~12 the manipulation statement \cpp{++iter} is used and for the \cpp{for} loop we would use \cpp{i++}.To get the content of the vector, we use the deference operator \cpp{*iter}. Note for the \cpp{for} loop we would use \cpp{values[i]}.\\

With the iterators erasing elements gets easier, since we can use the expression \cpp{values.erase(iter)}\link{https://en.cppreference.com/w/cpp/string/basic_string/erase} instead of \cpp{vlaues.erase(values.begin()+i)}. Note that the \cpp{erase} function returns the iterator of the element the iterator is pointing to after the deletion \cpp{iter = vlaues.erase(iter)} which is useful for some algorithms.

\lstinputlisting[language=C++,caption={Printing a vector using iterators.\label{code:for:iterator}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture3-for-iterator.cpp}



%----------------------------------------------------------------------------------------
\section{Algorithms}
\index{STL!algorithms}
\index{algorithms}
\label{sec:stl:algorithms}
%----------------------------------------------------------------------------------------
In this section some of the algorithms provided by the STL are studied. For a complete list of all available algorithms we refer to\link{https://en.cppreference.com/w/cpp/algorithm}. The median for a sorted list of numbers $\mathbf{v}=\{v_i \vert i =1,\ldots,n\}$ is given as
\begin{align}
median = \begin{cases}
v[\frac{n}{2}] \text{ if } n \text{ is even} \\
\frac{1}{2}\left( v[\frac{n}{2}] + v[\frac{n}{2}-1] \right) \text{else}
\end{cases} \text{.}
\end{align}
To compute the median of a \cpp{std::vector}, we have to sort the vector first. The STL provides the \cpp{std::sort} algorithm in the \cpp{#include <algorithm>} header. Listings~\ref{code:median} shows the computation of the median using the STL. In Line~6 a new feature \cpp{typedef}\link{https://en.cppreference.com/w/cpp/language/typedef} to shorten long lines of codes is introduced. In that case we do not want to type each time \cpp{std::vector<double>:: size_type} to get the data type of the vector size and want to use \cpp{vec_sz} instead. Each time the compiler recognizes \cpp{vec_sz} it will replace it by the long form. This is a neat feature to make the code more readable.\\

Line~13 shows how to use sort the values stored in the \cpp{std::vector} in Line~9--12. one has to provide the range of the vector to the sort function. Note that the current values in the vector will be replaced by the sorted ones. To keep the unsorted valued, a copy of the vector can be obtained by the \cpp{std::copy}\link{https://en.cppreference.com/w/cpp/algorithm/copy} algorithm.\\

\lstinputlisting[language=C++,caption={Computation of the median using the sorting algorithm provided by the STL.\label{code:median}},float,floatplacement=tb]{ParallelComputationMathExamples/chapter2/lecture2-median.cpp}

Another example is to compute the sum of all elements of a \cpp{std::vector} using a \cpp{for} loop or using the \cpp{std::accumulate}\link{https://en.cppreference.com/w/cpp/algorithm/accumulate} provided by the \cpp{#include <numerics>}\link{https://en.cppreference.com/w/cpp/header/numeric} header. Listing~\ref{code:algorithms:showcase} shows how to compute the sum and some neat algorithms. To fill a vector with the values one to ten, the function \cpp{std::ito}\link{https://en.cppreference.com/w/cpp/algorithm/iota} in Line~8 is used instead of writing a for loop. In Line~12--13 the sum is computed using the loop and in Line~17 the sum computed using the STL. One can easily see that the code in Line~17 is shorter and easier to understand. Therefore, it is recommended to use the STL were possible. In line~25--29 the values of the vector are printed to the standard output stream using a \cpp{for} loop. In Line~32 instead of using the \cpp{for} loop, the expression \cpp{std::for_each}\link{https://en.cppreference.com/w/cpp/algorithm/for_each} provided by the \cpp{#include <algorithm>} header is used. This lien of code iterates over all elements in the vector and call the function \cpp{print} and passes each element to the function. Note that the function can have only one argument and its type has to match the type of the vector.\\

There are many more algorithms in the STL as shown here. These algorithms will be introduced in the reaming parts of the book, especially with the numerical examples in Chapter~\ref{part:numerical:examples}. We recommend to have a look in the algorithms to write more efficient and less confusing code. For more details we refer to~\cite[Chapter~6]{andrew2000accelerated}.   


\begin{lstlisting}[language=c++,caption={Example for a function definition to compute the maximum of two numbers.\label{code:algorithms:showcase}},float,floatplacement=tb]
#include <vector> 
#include <iostream>
#include <numerics>
#include <algorithm>

void print(double v){
	std::cout << v << " ";
}

int main(){

std::vector<double> values (10);
std::iota(values.begin(), values.end(), 1);

//Compute the sum using a for loop
double sum = 0;
for( auto& v : values)
	sum += v;
std::cout << "Sum:" << sum << std::endl;

//Compute the sum using STL 
sum = std::accumulate((values.begin(), values.end(),0);
std::cout << "Sum:" << sum << std::endl;

//Check the result by printing the vector using a for loop
for( size_t i = 0 ; i < values.size(); i++)
	std::cout << values[i] << " ";
	std::cout << std::endl;

}

//Check the result by printing the vector using STL
std::for_each(values.begin(), values.end(), print);
\end{lstlisting}



%----------------------------------------------------------------------------------------
\section{Parallel Algorithms}
%\index{STL!algorithms}
%\index{algorithms}
%\label{sec:stl:algorithms}
%----------------------------------------------------------------------------------------

\newpage
\theendnotes
